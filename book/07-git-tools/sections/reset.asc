[[_git_reset]]
=== Усвідомлення Скидання (Reset)

До того, як переходити до більш спеціалізованих інструментів, поговорімо про `reset` (скинути) та `checkout` (отримати).
Ці дві команди найбільше збивають з пантелику, особливо коли ви вперше ними користуєтесь.
Вони роблять так багато всього, що спроба дійсно зрозуміти їх та використовувати правильно здається безнадійною.
Щоб усе ж таки це зробити, ми пропонуємо просту метафору.

==== Три Дерева

Набагато легше зрозуміти `reset` та `checkout`, якщо уявити, що Git керує вмістом трьох різних дерев.
``Деревом'' ми тут будемо називати ``колекцію файлів'', а не саме структуру даних.
(Є декілька випадків, в яких індекс насправді не поводиться як дерево, проте легше поки що уявляти його так.)

Git як система керує та маніпулює трьома деревами під час нормальної роботи:

[cols="1,2",options="header"]
|================================
| Дерево            | Роль
| HEAD              | Знімок останнього коміту, наступний батько
| Індекс            | Пропонований знімок наступного коміту
| Робоча Директорія | Пісочниця
|================================

===== HEAD

HEAD є вказівником на посилання поточної гілки, яка у свою чергу вказує на останній коміт, що був зроблений у цій гілці.
Це означає, що HEAD буде батьком наступного створеного коміту.
Зазвичай найпростіше думати про HEAD як про знімок *останнього коміту*.

Насправді, доволі легко побачити, як цей знімок виглядає.
Ось приклад отримання списку файлів директорії та SHA-1 суми кожного файла в знімку HEAD:

[source,console]
----
$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
----

Команди `cat-file` та `ls-tree` є командами низького рівня, якими не дуже користуються в повсякденній роботі, проте вони корисні при зʼясуванні того, що насправді коїться.

[[_the_index]]
===== Індекс

Індекс -- це *пропозиція наступного коміту*. Ця концепцію Git також має назву ``Область Додавання'', адже саме сюди дивиться Git при виконанні `git commit`.

Git заповнює цей індекс списком усього вмісту файлів, що був отриманий зі сховища до вашої робочої теки востаннє та яким він тоді був.
Потім ви замінюєте деякі з цих файлів новими версіями, та `git commit` перетворює це на дерево для нового коміту.

[source,console]
----
$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README
100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb
----

Ми знову скористалися `ls-files`, яка зазвичай виконується за лаштунками, показує як наразі виглядає індекс.

Технічно, індекс не є деревом - насправді його реалізовано як сплощений маніфест, проте для нас це достатньо близько.

===== Робоча Директорія.

Нарешті, є ваша робоча директорія.
Інші два дерева зберігають свій вміст у ефективний проте незручний спосіб: усередині теки `.git`.
Робоча Директорія розпаковує їх до реальних файлів, що дозволяє їх редагувати набагато легше.
Вважайте Робочу Директорію *пісочницею*, де ви можете спробувати зміни до того, як додати їх до індексу, а потім до історії.

[source,console]
----
$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
----

==== Порядок Праці

Головне призначення Git - записувати знімки вашого проекту в послідовно кращих станах за допомогою маніпулювання цими трьома деревами.

image::images/reset-workflow.png[]

Уявімо собі цей процес: припустімо, ви переходите до нової директорії з єдиним файлом у ній.
Ми назвемо цю версію файла *v1*, та будемо позначати її синім.
Тепер виконаємо `git init`, що створить сховище Git з посиланням HEAD, що вказує на ненароджену гілку (`master` ще не існує).

image::images/reset-ex1.png[]

Наразі тільки в дереві Робочої Директорії є якийсь вміст.

Тепер ми бажаємо зробити коміт з цим файлом, отже ми використовуємо `git add` щоб взяти вміст з Робочої Директорії та скопіювати його до Індексу.

image::images/reset-ex2.png[]

Потім виконуємо `git commit`, що бере вміст Індексу та зберігає його в незмінному знімку, створює обʼєкт коміту, що вказує на цей знімок, та оновлює `master`, щоб той вказував на цей коміт.

image::images/reset-ex3.png[]

Якщо ми виконаємо `git status`, то не побачимо ніяких змін, адже всі три дерева однакові.

Тепер ми хочемо зробити зміну в цьому файлі та зберегти їх у коміті.
Ми пройдемо той самий процес. Спочатку змінимо файл у робочій директорії.
Назвемо цю версію файла *v2*, та позначимо її червоним.

image::images/reset-ex4.png[]

Якщо ми зараз виконаємо `git status`, то побачимо файл червоним у ``Changes not staged for commit'', адже в цього елемента є різниця між Індексом та Робочою Директорією.
Далі виконуємо `git add` на ньому, щоб додати його до Індекса.

image::images/reset-ex5.png[]

Тепер якщо ми виконаємо `git status`, то побачимо файл зеленим.
під ``Changes to be commited'', адже Індекс та HEAD різняться - тобто, наш пропонований наступний коміт зараз відрізняється від останнього коміту.
Нарешті, виконуємо `git commit` щоб завершити коміт.

image::images/reset-ex6.png[]

Тепер `git status` нічого не виведе, адже всі три дерева знову однакові.

Переключення гілок та клонування проходить за схожим процесом.
Коли ви отримуєте (checkout) гілку, Git перенаправляє *HEAD* до нового посилання гілки, заповнює *Індекс* знімком того коміту, далі копіює вміст *Індексу* до *Робочої Директорії*.

==== The Role of Reset

The `reset` command makes more sense when viewed in this context.

For the purposes of these examples, let's say that we've modified `file.txt` again and committed it a third time. So now our history looks like this:

image::images/reset-start.png[]

Let's now walk through exactly what `reset` does when you call it. It directly manipulates these three trees in a simple and predictable way.
It does up to three basic operations.

===== Step 1: Move HEAD

The first thing `reset` will do is move what HEAD points to.
This isn't the same as changing HEAD itself (which is what `checkout` does); `reset` moves the branch that HEAD is pointing to.
This means if HEAD is set to the `master` branch (i.e. you're currently on the `master` branch), running `git reset 9e5e6a4` will start by making `master` point to `9e5e6a4`.

image::images/reset-soft.png[]

No matter what form of `reset` with a commit you invoke, this is the first thing it will always try to do.
With `reset --soft`, it will simply stop there.

Now take a second to look at that diagram and realize what happened: it essentially undid the last `git commit` command.
When you run `git commit`, Git creates a new commit and moves the branch that HEAD points to up to it.
When you `reset` back to `HEAD~` (the parent of HEAD), you are moving the branch back to where it was, without changing the Index or Working Directory.
You could now update the Index and run `git commit` again to accomplish what `git commit --amend` would have done (see <<_git_amend>>).

===== Step 2: Updating the Index (--mixed)

Note that if you run `git status` now you'll see in green the difference between the Index and what the new HEAD is.

The next thing `reset` will do is to update the Index with the contents of whatever snapshot HEAD now points to.

image::images/reset-mixed.png[]

If you specify the `--mixed` option, `reset` will stop at this point.
This is also the default, so if you specify no option at all (just `git reset HEAD~` in this case), this is where the command will stop.

Now take another second to look at that diagram and realize what happened: it still undid your last `commit`, but also _unstaged_ everything.
You rolled back to before you ran all your `git add` and `git commit` commands.

===== Step 3: Updating the Working Directory (--hard)

The third thing that `reset` will do is to make the Working Directory look like the Index.
If you use the `--hard` option, it will continue to this stage.

image::images/reset-hard.png[]

So let's think about what just happened.
You undid your last commit, the `git add` and `git commit` commands, **and** all the work you did in your working directory.

It's important to note that this flag (`--hard`) is the only way to make the `reset` command dangerous, and one of the very few cases where Git will actually destroy data.
Any other invocation of `reset` can be pretty easily undone, but the `--hard` option cannot, since it forcibly overwrites files in the Working Directory.
In this particular case, we still have the *v3* version of our file in a commit in our Git DB, and we could get it back by looking at our `reflog`, but if we had not committed it, Git still would have overwritten the file and it would be unrecoverable.

===== Recap

The `reset` command overwrites these three trees in a specific order, stopping when you tell it to:

1. Move the branch HEAD points to _(stop here if `--soft`)_
2. Make the Index look like HEAD _(stop here unless `--hard`)_
3. Make the Working Directory look like the Index

==== Reset With a Path

That covers the behavior of `reset` in its basic form, but you can also provide it with a path to act upon.
If you specify a path, `reset` will skip step 1, and limit the remainder of its actions to a specific file or set of files.
This actually sort of makes sense – HEAD is just a pointer, and you can't point to part of one commit and part of another.
But the Index and Working directory _can_ be partially updated, so reset proceeds with steps 2 and 3.

So, assume we run `git reset file.txt`.
This form (since you did not specify a commit SHA-1 or branch, and you didn't specify `--soft` or `--hard`) is shorthand for `git reset --mixed HEAD file.txt`, which will:

1. Move the branch HEAD points to _(skipped)_
2. Make the Index look like HEAD _(stop here)_

So it essentially just copies `file.txt` from HEAD to the Index.

image::images/reset-path1.png[]

This has the practical effect of _unstaging_ the file.
If we look at the diagram for that command and think about what `git add` does, they are exact opposites.

image::images/reset-path2.png[]

This is why the output of the `git status` command suggests that you run this to unstage a file.
(See <<_unstaging>> for more on this.)

We could just as easily not let Git assume we meant ``pull the data from HEAD'' by specifying a specific commit to pull that file version from.
We would just run something like `git reset eb43bf file.txt`.

image::images/reset-path3.png[]

This effectively does the same thing as if we had reverted the content of the file to *v1* in the Working Directory, ran `git add` on it, then reverted it back to *v3* again (without actually going through all those steps).
If we run `git commit` now, it will record a change that reverts that file back to *v1*, even though we never actually had it in our Working Directory again.

It's also interesting to note that like `git add`, the `reset` command will accept a `--patch` option to unstage content on a hunk-by-hunk basis.
So you can selectively unstage or revert content.

==== Squashing

Let's look at how to do something interesting with this newfound power – squashing commits.

Say you have a series of commits with messages like ``oops.'', ``WIP'' and ``forgot this file''.
You can use `reset` to quickly and easily squash them into a single commit that makes you look really smart.
(<<_squashing>> shows another way to do this, but in this example it's simpler to use `reset`.)

Let's say you have a project where the first commit has one file, the second commit added a new file and changed the first, and the third commit changed the first file again.
The second commit was a work in progress and you want to squash it down.

image::images/reset-squash-r1.png[]

You can run `git reset --soft HEAD~2` to move the HEAD branch back to an older commit (the first commit you want to keep):

image::images/reset-squash-r2.png[]

And then simply run `git commit` again:

image::images/reset-squash-r3.png[]

Now you can see that your reachable history, the history you would push, now looks like you had one commit with `file-a.txt` v1, then a second that both modified `file-a.txt` to v3 and added `file-b.txt`. The commit with the v2 version of the file is no longer in the history.


==== Check It Out

Finally, you may wonder what the difference between `checkout` and `reset` is.
Like `reset`, `checkout` manipulates the three trees, and it is a bit different depending on whether you give the command a file path or not.

===== Without Paths

Running `git checkout [branch]` is pretty similar to running `git reset --hard [branch]` in that it updates all three trees for you to look like `[branch]`, but there are two important differences.

First, unlike `reset --hard`, `checkout` is working-directory safe; it will check to make sure it's not blowing away files that have changes to them.
Actually, it's a bit smarter than that – it tries to do a trivial merge in the Working Directory, so all of the files you _haven't_ changed in  will be updated.
`reset --hard`, on the other hand, will simply replace everything across the board without checking.

The second important difference is how it updates HEAD.
Where `reset` will move the branch that HEAD points to, `checkout` will move HEAD itself to point to another branch.

For instance, say we have `master` and `develop` branches which point at different commits, and we're currently on `develop` (so HEAD points to it).
If we run `git reset master`, `develop` itself will now point to the same commit that `master` does.
If we instead run `git checkout master`, `develop` does not move, HEAD itself does.
HEAD will now point to `master`.

So, in both cases we're moving HEAD to point to commit A, but _how_ we do so is very different.
`reset` will move the branch HEAD points to, `checkout` moves HEAD itself.

image::images/reset-checkout.png[]

===== With Paths

The other way to run `checkout` is with a file path, which, like `reset`, does not move HEAD.
It is just like `git reset [branch] file` in that it updates the index with that file at that commit, but it also overwrites the file in the working directory.
It would be exactly like `git reset --hard [branch] file` (if `reset` would let you run that) – it's not working-directory safe, and it does not move HEAD.

Also, like `git reset` and `git add`, `checkout` will accept a `--patch` option to allow you to selectively revert file contents on a hunk-by-hunk basis.

==== Summary

Hopefully now you understand and feel more comfortable with the `reset` command, but are probably still a little confused about how exactly it differs from `checkout` and could not possibly remember all the rules of the different invocations.

Here's a cheat-sheet for which commands affect which trees.
The ``HEAD'' column reads ``REF'' if that command moves the reference (branch) that HEAD points to, and ``HEAD'' if it moves HEAD itself.
Pay especial attention to the 'WD Safe?' column – if it says *NO*, take a second to think before running that command.

[options="header", cols="3,1,1,1,1"]
|================================
| | HEAD | Index | Workdir | WD Safe?
| *Commit Level* | | | |
| `reset --soft [commit]` | REF | NO | NO | YES
| `reset [commit]` | REF | YES | NO | YES
| `reset --hard [commit]` | REF | YES | YES | *NO*
| `checkout [commit]` | HEAD | YES | YES | YES
| *File Level* | | | |
| `reset (commit) [file]` | NO | YES | NO | YES
| `checkout (commit) [file]` | NO | YES | YES | *NO*
|================================
